mod funcs;
mod db;
mod user;
mod machine;

use spacetraders::client;
use std::env;
use dotenv::dotenv;
use tokio::time::Duration;
use spacetraders::shared::{LoanType, Good};
use tokio::sync::mpsc;
use crate::machine::ShipResponse;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    dotenv().ok();

    let username_base = env::var("USERNAME_BASE").unwrap();
    let postgres_host = env::var("POSTGRES_HOST").unwrap();
    let postgres_port = env::var("POSTGRES_PORT").unwrap().parse::<i32>().unwrap();
    let postgres_username = env::var("POSTGRES_USERNAME").unwrap();
    let postgres_password = env::var("POSTGRES_PASSWORD").unwrap();
    let postgres_database = env::var("POSTGRES_DATABASE").unwrap();
    let enable_scouts = env::var("ENABLE_SCOUTS").unwrap().parse::<bool>().unwrap();

    let pg_pool = db::get_db_pool(postgres_host, postgres_port, postgres_username, postgres_password, postgres_database).await?;

    db::run_migrations(pg_pool.clone()).await?;

    // Algorithm. Create the main user account (or get from db). Get the number of locations
    // in the system. Create (or get from db) X scout accounts (where X is number of locations in
    // the system). Send each scout account to the location they are assigned.

    let http_client = client::get_http_client();

    if funcs::is_api_in_maintenance_mode(http_client.clone()).await {
        loop {
            println!("Detected SpaceTraders API in maintenance mode (status code 503). Sleeping for 60 seconds and trying again");
            tokio::time::sleep(Duration::from_secs(60)).await;

            if !funcs::is_api_in_maintenance_mode(http_client.clone()).await {
                break;
            }
        }
    }

    // When an API reset occurs all the scouts will being to fail making requests.
    // As soon as all the scouts fail this pod will restart. Upon restart we will check
    // if the API is in maintenance mode (status code 503) if it is then we will wait for
    // maintenance mode to end. After that ends if the main user is unable to make a requests
    // we can assume that the API has been reset and we need to reset ourselves.
    let user = user::User::new(http_client.clone(), pg_pool.clone(), format!("{}-main", username_base), "main".to_string(), None, None).await;
    if user.is_err() {
        db::reset_db(pg_pool.clone()).await?;
        // Now that the tables have been we will panic so that the pod will restart and the tables will be recreated
        panic!("Unable to connect using the main user. Assuming an API reset. Backing up data and clearing the database");
    }

    let mut user = user.unwrap();

    let system_info = user.get_systems().await?;

    for system in &system_info.systems {
        for location in &system.locations {
            db::persist_system_location(pg_pool.clone(), system, location).await?;
        }
    }

    println!("## Begin System Messages ----------------------------------------------------------");
    for system in &system_info.systems {
        for location in &system.locations {
            if let Some(messages) = &location.messages {
                for message in messages {
                    println!("Location: {} Message: {}", location.symbol, message)
                }
            }
        }
    }
    println!("## End System Messages ------------------------------------------------------------");

    let mut user_handles = Vec::new();

    // have two machines

    // a trader machine and a scout machine

    if enable_scouts {
        let mut scouts: Vec<user::User> = Vec::new();

        for system in &system_info.systems {
            for location in &system.locations {
                let scout_user = user::User::new(
                    http_client.clone(),
                    pg_pool.clone(),
                    format!("{}-scout-{}", username_base, location.symbol),
                    "scout".to_string(),
                    Some(system.symbol.clone()),
                    Some(location.symbol.clone()),
                ).await?;

                scouts.push(scout_user);
            }
        }

        for scout in scouts {
            let pg_pool = pg_pool.clone();
            user_handles.push(tokio::spawn(async move {
                let mut scout = scout.clone();
                let assigned_location = scout.location_symbol.clone().unwrap();
                // 1. if the user doesn't have enough credits take out a startup loan
                println!("Scout {} -- user info {:?}", scout.username, scout.info);
                if scout.info.user.credits == 0 {
                    println!("Scout {} -- Requesting new {:?} loan", scout.username, LoanType::Startup);
                    // assume that if the user has 0 credits that the user needs to take out a loan
                    scout.request_new_loan(LoanType::Startup).await?;
                }

                // 2. if the user doesn't have any ships then buy the fastest one that the user can afford that is in the system assigned to the scout
                if scout.info.user.ships.is_empty() {
                    scout.purchase_fastest_ship(scout.system_symbol.clone().unwrap()).await?;
                }

                println!("Ship {} -- Found {} ships for user {}", scout.username, scout.info.user.ships.len(), scout.username);
                if !scout.info.user.ships.is_empty() {
                    scout.maybe_wait_for_ship_to_arrive(0).await?;

                    scout.fill_ship_with_max_good(0, Good::Fuel).await?;

                    // if the scout isn't at it's assigned location then send it there
                    scout.send_ship_to_location(0, assigned_location)
                        .await.expect("Unable to send ship to location");

                    // now start collecting marketplace data every 3 minutes
                    loop {
                        println!("Ship {} -- is at {} harvesting marketplace data", scout.username, assigned_location.clone());

                        scout.update_marketplace_data().await?;

                        println!("Ship {} -- is waiting for 3 minutes to get another round of data", scout.username);
                        tokio::time::sleep(Duration::from_secs(60 * 3)).await;
                    }
                }

                Ok::<(), Box<dyn std::error::Error + Send>>(())
            }));
        }
    }

    // One task per user, each of those will create new tasks for each of it's ships
    // The main task will handle upgrades by checking the users credits and ships periodically
    // The main task will be able to create new ships and push them into the ship_handles array to
    // be awaited upon later
    // That's all that we need for creating new ships, but upgrading ships we need to be able to
    // notify a ship task that it needs to be upgraded

    user_handles.push(tokio::spawn(async move {
        // 1. if the user doesn't have enough credits take out a startup loan
        if user.info.user.credits == 0 {
            println!("User {} -- Requesting new {:?} loan", user.username, LoanType::Startup);
            // assume that if the user has 0 credits that the user needs to take out a loan
            user.request_new_loan(LoanType::Startup).await?;
        }

        // 2. if the user doesn't have any ships then buy the fastest one that the user can afford that is in the system assigned to the scout
        if user.info.user.ships.is_empty() {
            user.purchase_fastest_ship("OE".to_string()).await?;
        }

        let (tx, mut rx) = mpsc::channel::<ShipResponse>(32);

        let mut ship_handles = Vec::new();
        for ship in user.info.user.ships {
            let user = user.clone();
            let ship = ship.clone();
            let ship_tx = tx.clone();
            ship_handles.push(tokio::spawn(async move {
                let mut ship = machine::Ship::new(
                    http_client.clone(),
                    pg_pool.clone(),
                    user.username,
                    user.token,
                    ship.id.clone(),
                    machine::ShipAssignment::Trader,
                    ship,
                    ship_tx
                );

                // Reset the main user ship
                ship.sell_all_cargo().await?;

                Ok::<(), Box<dyn std::error::Error + Send>>(())
            }));
        }

        while let Some(message) = rx.recv().await {
            println!("GOT = {:?}", message);
        }

        loop {
            // main user will find the best trade from their current location
            // we are only working with one ship so we'll just user the main users first ship
            let routes = user.get_routes_for_ship(0).await?;
            let best_route = routes.get(0);

            // TODO: It is possible that the best_route doesn't have enough quantity to make a full
            //       trade so maybe pick the second best route if there isn't enough quantity at the
            //       from location

            if let Some(best_route) = best_route {
                println!("Good to trade {:?}", best_route.good);
                println!("Location to trade at {}", best_route.sell_location_symbol);

                // fill ship with enough fuel to get to the other location
                let fuel_required = best_route.fuel_required.ceil() as i32;

                // We don't have to move the ship to the purchase location because we got the routes
                // specifically for the location that this ship is already in

                println!("Route requires {} fuel", fuel_required);

                user.ensure_ship_has_enough_fuel(0, fuel_required).await?;

                // make purchase
                user.fill_ship_with_max_good(0, best_route.good).await?;

                user.send_ship_to_location(0, best_route.sell_location_symbol.clone()).await?;

                // sell and repeat
                user.sell_max_good(0, best_route.good).await?;

                // TODO: Keep track of users credits through time
                //       Keep track of users flight plans, purchases, sells, and routes (cdv)

                // TODO: Automated upgrades. When credits hits X amount purchase a new ship
                //       When credits hits X amount upgrade a type of ship to another type of ship
                //       This will also require us to actually manage more that one ship at a time
            }
        }

        futures::future::join_all(ship_handles).await;
    }));

    futures::future::join_all(user_handles).await;

    Ok(())
}
